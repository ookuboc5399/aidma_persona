シートのC36にプロット②を記載するようにする。



1. 「一括読み込み実行」ボタンを押した場合


  これは、Googleスプレッドシートから情報を取得して画面に表示するまでの流れです。


   1. [フロントエンド] あなたがボタンをクリックすると、handleReadSheet
      という関数が実行されます。
   2. [フロントエンド] handleReadSheetは、バックエンドのAPI /api/sheets/read
      に対して、「SSリスク」シートのURLを付けて「このシートの情報をください」という
      リクエストを送信します。
   3. [バックエンド] /api/sheets/read はリクエストを受け取ると、Google Sheets
      APIを通じて以下の処理を実行します。
      a. 「SSリスク」シートにアクセスし、D列からH列の情報をすべて取得します。
      b. H列が「未」の行だけに絞り込みます。
      c. 絞り込んだ行のリストを元に、E列のURL（子スプレッドシート）とD列のシート名
  を組み合わせ、対象となる全シートからご指定の12項目（代表者、住所、トーク5種など）
  の情報を取得するリクエストを、並行して（Promise.allで）Googleに一斉に送信します。
      d.
  Googleから返ってきたすべての情報を一つの大きなリスト（JSON形式）にまとめます。
   4. [フロントエンド] バックエンドから返ってきたリストを受け取ります。
   5. [フロントエンド]
      受け取ったリストを元に画面を再描画し、あなたが見ている結果一覧を表示します。

  ---



  2. 各行の「AI改善案を生成」ボタンを押した場合

  これは、特定の1社に対してAIの改善案を生成する流れです。


   1. [フロントエンド] あなたが特定の行の緑色のボタンを押すと、handleGenerateTalk
      という関数が、その行の情報（12項目のデータ）を持って実行されます。
   2. [フロントエンド] handleGenerateTalkは、バックエンドのAPI /api/rag/talk
      に対して、「この企業のデータを使って改善案を考えてください」というリクエストを
      送信します。
   3. [バックエンド] /api/rag/talk
      はデータを受け取ると、以下のRAG（Retrieval-Augmented
      Generation）処理を実行します。
      a. 検索クエリ生成: 受け取ったデータ（事業内容など）を元に、Supabaseから関連ナ
  レッジを検索するためのキーワード（クエリ）を生成します。
      b. ベクトル化: OpenAIのEmbedding
  APIを使い、そのクエリをベクトル（数値の配列）に変換します。
      c. 近傍検索: Supabase(pgvector)にそのベクトルを送り、内容が近い社内ナレッジを
  数件検索して取得します。
      d. プロンプト生成:
  取得した社内ナレッジと、フロントエンドから受け取った12項目の企業情報をすべて組み合
  わせ、GPT-4o-miniに対する最終的な指示書（プロンプト）を完成させます。
      e. AI実行: 完成したプロンプトをOpenAIに送り、改善トークを生成させます。
      f. 応答:
  AIから返ってきたJSON（改善対象、改善トーク、理由）をフロントエンドに返します。
   4. [フロントエンド] バックエンドから返ってきた改善案を受け取り、該当する行に「AI
      からの改善提案」として表示します。

  ---

  3. 「全件一括生成」ボタンを押した場合

  これは、上記2番の処理を、画面に表示されている全企業に対して一度に行う流れです。


   1. [フロントエンド] あなたが特定の行の緑色のボタンを押すと、handleGenerateTalk
      という関数が、その行の情報（12項目のデータ）を持って実行されます。
   2. [フロントエンド] handleGenerateTalkは、バックエンドのAPI /api/rag/talk
      に対して、「この企業のデータを使って改善案を考えてください」というリクエス
      トを送信します。
   1. [フロントエンド] あなたがオレンジ色のボタンを押すと、handleGenerateAllTalks
      という関数が実行されます。
   2. [フロントエンド] この関数は、画面に表示されている企業のうち、まだ改善案が生成
      されていないすべての企業をリストアップします。
   3. [フロントエンド] リストアップした全企業に対して、上記2番で説明した
      /api/rag/talk へのリクエストを、並行して（Promise.allで）一斉に送信します。
   4. [バックエンド]
      各リクエストに対して、上記2-cからのRAG処理をそれぞれ実行します。
   5. [フロントエンド] バックエンドから返ってきた改善案を一つずつ受け取り、すべての
      処理が終わったら、画面を一度に更新して全企業の改善案を表示します。




ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー



        データが送られるタイミングは、大きく分けて2回あります。


   1. 1回目（検索用）： Supabaseから関連ナレッジを探すため
   2. 2回目（生成用）： すべての情報をまとめて改善案を考えてもらうため

  以下は、「AI改善案を生成」ボタンを押してからの、APIをまたいだデータの流れです。



    1 sequenceDiagram
    2     participant FE as フロントエンド
    3     participant BE as バックエンドAPI (/api/rag/talk)
    4     participant OpenAI_Emb as OpenAI (Embedding)
    5     participant Supabase
    6     participant OpenAI_Chat as OpenAI (Chat)
    7 
    8     FE->>BE: (1) シートから取得した全12項目のデータを送信
    9     
   10     BE->>OpenAI_Emb: (2) 検索用クエリ（事業内容＋トークの一部）を送信
   11     OpenAI_Emb-->>BE: (3) クエリのベクトル（数値配列）を返却
   12     
   13     BE->>Supabase: (4) 受け取ったベクトルを送信
   14     Supabase-->>BE: (5) 意味が近いナレッジ（テキスト）を返却
   15     
   16     BE->>OpenAI_Chat: (6) 【全情報】をプロンプトとして送信<br/>-
      シートの全12項目<br/>- Supabaseのナレッジ<br/>- 指示命令
   17     OpenAI_Chat-->>BE: (7) 改善案（JSON）を返却
   18     
   19     BE-->>FE: (8) 最終的な改善案を返却


  各ステップの詳細


  ステップ1：フロントエンド → バックエンド
  あなたが「AI改善案を生成」ボタンを押すと、UIに表示されている企業の全情報（代表
  者、住所、トーク5種など、12項目すべて）が、まず私たちのバックエンドAPI（/api/ra
  g/talk）に送られます。


  ステップ2 & 3：バックエンド → OpenAI (Embedding) → バックエンド
  【1回目のOpenAI APIコール】
  バックエンドは、受け取った12項目の情報すべてをいきなりOpenAIに送りません。
  まず、Supabaseで効率的に検索するために、「事業内容」と「対象者通話トーク」だけ
  を抜き出して、「こういう内容に関連するナレッジを探したい」という短い検索クエリ
  を作成します。


  そして、この検索クエリだけをOpenAIのEmbedding APIに送ります。
  すると、OpenAIはこのクエリの「意味」を解釈し、数値の配列（ベクトル）に変換して
  返します。


  ステップ4 & 5：バックエンド → Supabase → バックエンド
  バックエンドは、OpenAIから受け取ったベクトルをSupabaseに送ります。
  Supabaseは、このベクトルと意味が近いナレッジをデータベース内から探し出し、その
  ナレッジのテキストをバックエンドに返します。


  ステップ6 & 7：バックエンド → OpenAI (Chat) → バックエンド
  【2回目のOpenAI APIコール】
  ここが本番です。バックエンドは、これまでに集めたすべての情報を一つにまとめます
  。


   * 情報1: フロントエンドから受け取った、企業の全12項目のデータ
   * 情報2: Supabaseから取り寄せた、関連ナレッジのテキスト
   * 情報3: AIへの詳細な指示命令（「あなたプロの営業コンサルタントです...」の部分）


  この3つの情報をすべて結合した巨大なプロンプトを作成し、それをOpenAIのChat 
  Completions API（gpt-4o-mini）に送ります。
  gpt-4o-mini は、この豊富な情報を元に深く考察し、最終的な改善案（改善対象、改善
  トーク、理由）をJSON形式で生成して返します。


  ステップ8：バックエンド → フロントエンド
  バックエンドは、AIから受け取った改善案のJSONをそのままフロントエンドに返し、あ
  なたの画面に結果が表示されます。


  ---
  このように、1回目は検索のためにOpenAIの能力を使い、2回目にすべての情報を集めて
  本番の回答を生成するために使う、という2段階の構成になっています。